package controller;

import model.*;
import view.PlantUMLGenerator;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.Modifier;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.Collectors;

public class UMLParserController {
    
    // Shared resources
    private final UMLModel umlModel = new UMLModel();
    private final ReentrantLock modelLock = new ReentrantLock();
    private final ExecutorService executorService;
    private final PlantUMLGenerator generator = new PlantUMLGenerator();
    
    // Thread-local parsers to avoid sharing JavaParser instances
    private final ThreadLocal<JavaParser> parserThreadLocal = ThreadLocal.withInitial(JavaParser::new);
    
    public UMLParserController() {
        this.executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    }
    
    public UMLParserController(int threadCount) {
        this.executorService = Executors.newFixedThreadPool(threadCount);
    }
    
    /**
     * Parse multiple files concurrently into shared UMLModel
     */
    public void parseFiles(List<Path> filePaths) throws Exception {
        if (filePaths.isEmpty()) {
            return;
        }
        
        if (filePaths.size() == 1) {
            // Single file - no need for concurrency overhead
            parseFile(filePaths.get(0));
            return;
        }
        
        // Create latch for coordination
        CountDownLatch latch = new CountDownLatch(filePaths.size());
        
        // Submit all parsing tasks
        for (Path filePath : filePaths) {
            executorService.submit(() -> {
                try {
                    parseFile(filePath);
                } catch (Exception e) {
                    System.err.println("Error parsing file: " + filePath + " - " + e.getMessage());
                } finally {
                    latch.countDown(); // Always count down, even on error
                }
            });
        }
        
        // Wait for all tasks to complete
        try {
            latch.await(); // Block until all tasks finish
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Parsing interrupted", e);
        }
    }
    
    /**
     * Parse multiple files concurrently with timeout
     */
    public boolean parseFilesWithTimeout(List<Path> filePaths, long timeout, TimeUnit unit) throws Exception {
        if (filePaths.isEmpty()) {
            return true;
        }
        
        if (filePaths.size() == 1) {
            parseFile(filePaths.get(0));
            return true;
        }
        
        CountDownLatch latch = new CountDownLatch(filePaths.size());
        
        // Submit all parsing tasks
        for (Path filePath : filePaths) {
            executorService.submit(() -> {
                try {
                    parseFile(filePath);
                } catch (Exception e) {
                    System.err.println("Error parsing file: " + filePath + " - " + e.getMessage());
                } finally {
                    latch.countDown();
                }
            });
        }
        
        // Wait for all tasks to complete or timeout
        try {
            return latch.await(timeout, unit);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Parsing interrupted", e);
        }
    }
    
    /**
     * Parse single file and add to shared model
     */
    public void parseFile(Path filePath) throws Exception {
        // Parse file without holding lock (most time-consuming operation)
        ClassModel classModel = parseJavaFile(filePath);
        
        if (classModel != null) {
            // Only lock when modifying shared model
            modelLock.lock();
            try {
                umlModel.addClassToDiagram(classModel);
            } finally {
                modelLock.unlock();
            }
        }
    }
    
    /**
     * Add relationship to shared model (thread-safe)
     */
    public void addRelationship(DependencyModel relationship) {
        modelLock.lock();
        try {
            umlModel.addRelationshipToDiagram(relationship);
        } finally {
            modelLock.unlock();
        }
    }
    
    /**
     * Batch add multiple relationships (more efficient than individual adds)
     */
    public void addRelationships(List<DependencyModel> relationships) {
        if (relationships.isEmpty()) {
            return;
        }
        
        modelLock.lock();
        try {
            for (DependencyModel relationship : relationships) {
                umlModel.addRelationshipToDiagram(relationship);
            }
        } finally {
            modelLock.unlock();
        }
    }
    
    /**
     * Get thread-safe copy of current model state
     */
    public UMLModel getUMLModel() {
        modelLock.lock();
        try {
            // Create defensive copy
            UMLModel copy = new UMLModel();
            
            // Copy all classes
            for (ClassModel classModel : umlModel.getClasses()) {
                copy.addClassToDiagram(classModel);
            }
            
            // Copy all relationships
            for (DependencyModel relationship : umlModel.getRelationships()) {
                copy.addRelationshipToDiagram(relationship);
            }
            
            return copy;
        } finally {
            modelLock.unlock();
        }
    }
    
    /**
     * Generate PlantUML from current shared model state
     */
    public String generatePlantUML() {
        modelLock.lock();
        try {
            return generator.generatePlantUML(umlModel);
        } finally {
            modelLock.unlock();
        }
    }
    
    /**
     * Clear the shared model (thread-safe)
     */
    public void clearModel() {
        modelLock.lock();
        try {
            // Since UMLModel doesn't have a clear method, create a new one
            // Note: You might want to add a clear() method to UMLModel
            umlModel.getClasses().clear();
            umlModel.getRelationships().clear();
        } finally {
            modelLock.unlock();
        }
    }
    
    /**
     * Get current statistics without full model copy
     */
    public ModelStats getStats() {
        modelLock.lock();
        try {
            return new ModelStats(
                umlModel.getClasses().size(),
                umlModel.getRelationships().size()
            );
        } finally {
            modelLock.unlock();
        }
    }
    
    private ClassModel parseJavaFile(Path filePath) throws Exception {
        // Use thread-local parser to avoid sharing
        JavaParser parser = parserThreadLocal.get();
        CompilationUnit cu = parser.parse(filePath).getResult().orElseThrow();
        
        for (ClassOrInterfaceDeclaration type : cu.findAll(ClassOrInterfaceDeclaration.class)) {
            ClassModel classModel = new ClassModel(type.getNameAsString());
            
            // Set class type
            classModel.setIsInterface(type.isInterface());
            classModel.setIsAbstract(type.getModifiers().contains(Modifier.Keyword.ABSTRACT));
            
            // Parse fields
            for (FieldDeclaration field : type.getFields()) {
                parseField(field, classModel);
            }
            
            // Parse methods
            for (MethodDeclaration method : type.getMethods()) {
                parseMethod(method, classModel);
            }
            
            return classModel;
        }
        
        return null;
    }
    
    private void parseField(FieldDeclaration field, ClassModel classModel) {
        Visibility visibility = getVisibility(field);
        boolean isStatic = field.getModifiers().contains(Modifier.Keyword.STATIC);
        boolean isFinal = field.getModifiers().contains(Modifier.Keyword.FINAL);
        String returnType = field.getElementType().asString();
        
        field.getVariables().forEach(variable -> {
            String name = variable.getNameAsString();
            String defaultValue = variable.getInitializer()
                    .map(init -> init.toString())
                    .orElse(null);
            
            FieldModel fieldModel = new FieldModel(visibility, isStatic, isFinal, 
                    returnType, name, defaultValue);
            classModel.addField(fieldModel);
        });
    }
    
    private void parseMethod(MethodDeclaration method, ClassModel classModel) {
        Visibility visibility = getVisibility(method);
        boolean isStatic = method.getModifiers().contains(Modifier.Keyword.STATIC);
        boolean isFinal = method.getModifiers().contains(Modifier.Keyword.FINAL);
        String returnType = method.getType().asString();
        String name = method.getNameAsString();
        
        MethodModel methodModel = new MethodModel(visibility, isStatic, isFinal, returnType, name);
        
        // Parse parameters
        method.getParameters().forEach(param -> {
            String paramType = param.getType().asString();
            String paramName = param.getNameAsString();
            methodModel.getParameters().add(new ParameterModel(paramType, paramName));
        });
        
        classModel.addMethod(methodModel);
    }
    
    private Visibility getVisibility(NodeWithModifiers<?> node) {
        if (node.getModifiers().contains(Modifier.Keyword.PUBLIC)) {
            return Visibility.PUBLIC;
        }
        if (node.getModifiers().contains(Modifier.Keyword.PRIVATE)) {
            return Visibility.PRIVATE;
        }
        if (node.getModifiers().contains(Modifier.Keyword.PROTECTED)) {
            return Visibility.PROTECTED;
        }
        return Visibility.PACAKAGE_PRIVATE;
    }
    
    public void shutdown() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
        
        // Clean up thread-local resources
        parserThreadLocal.remove();
    }
    
    /**
     * Simple stats class to avoid full model copying for basic info
     */
    public static class ModelStats {
        public final int classCount;
        public final int relationshipCount;
        
        public ModelStats(int classCount, int relationshipCount) {
            this.classCount = classCount;
            this.relationshipCount = relationshipCount;
        }
        
        @Override
        public String toString() {
            return String.format("Classes: %d, Relationships: %d", classCount, relationshipCount);
        }
    }
    
    // Example usage
    public static void main(String[] args) {
        UMLParserController controller = new UMLParserController();
        
        try {
            // Parse files into shared model
            controller.parseDirectory(Path.of("src/main/java"));
            
            // Check progress
            System.out.println("Current stats: " + controller.getStats());
            
            // Generate PlantUML from shared model
            String plantUML = controller.generatePlantUML();
            System.out.println(plantUML);
            
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            controller.shutdown();
        }
    }
}