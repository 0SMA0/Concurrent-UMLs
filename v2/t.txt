package controller;

import model.*;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Modifier;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.resolution.types.ResolvedType;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.stream.Stream;
import java.util.concurrent.*;
import java.util.concurrent.locks.ReentrantLock;

public class UMLParserController {
    private final JavaParser parser = new JavaParser();
    private final UMLModel umlModel = new UMLModel();
    private final ReentrantLock modelLock = new ReentrantLock();
    private final ExecutorService executorService = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors()
    );

    public UMLModel parseDirectory(Path directoryPath) throws IOException, InterruptedException {
        List<Path> javaFiles = findJavaFiles(directoryPath);
        CountDownLatch latch = new CountDownLatch(javaFiles.size());
        BlockingQueue<Path> fileQueue = new LinkedBlockingQueue<>(javaFiles);

        // Parse files concurrently
        for (int i = 0; i < Math.min(javaFiles.size(), Runtime.getRuntime().availableProcessors()); i++) {
            executorService.submit(new FileParserTask(fileQueue, latch));
        }

        latch.await();
        
        // After parsing all classes, analyze relationships
        analyzeRelationships();
        
        return umlModel;
    }

    private List<Path> findJavaFiles(Path directoryPath) throws IOException {
        try (Stream<Path> paths = Files.walk(directoryPath)) {
            return paths
                .filter(path -> path.toString().endsWith(".java"))
                .filter(Files::isRegularFile)
                .toList();
        }
    }

    private class FileParserTask implements Runnable {
        private final BlockingQueue<Path> fileQueue;
        private final CountDownLatch latch;

        public FileParserTask(BlockingQueue<Path> fileQueue, CountDownLatch latch) {
            this.fileQueue = fileQueue;
            this.latch = latch;
        }

        @Override
        public void run() {
            try {
                Path filePath;
                while ((filePath = fileQueue.poll()) != null) {
                    parseFile(filePath);
                    latch.countDown();
                }
            } catch (Exception e) {
                e.printStackTrace();
                latch.countDown();
            }
        }
    }

    private void parseFile(Path filePath) throws Exception {
        CompilationUnit cu = parser.parse(filePath).getResult().orElseThrow();

        for (ClassOrInterfaceDeclaration type : cu.findAll(ClassOrInterfaceDeclaration.class)) {
            ClassModel classModel = parseClass(type);
            
            modelLock.lock();
            try {
                umlModel.addClassToDiagram(classModel);
            } finally {
                modelLock.unlock();
            }
        }
    }

    private ClassModel parseClass(ClassOrInterfaceDeclaration classDecl) {
        ClassModel classModel = new ClassModel(classDecl.getNameAsString());
        classModel.setIsInterface(classDecl.isInterface());
        classModel.setIsAbstract(classDecl.hasModifier(Modifier.Keyword.ABSTRACT));

        // Parse fields
        for (FieldDeclaration field : classDecl.getFields()) {
            for (VariableDeclarator variable : field.getVariables()) {
                FieldModel fieldModel = parseField(field, variable);
                classModel.addField(fieldModel);
            }
        }

        // Parse methods
        for (MethodDeclaration method : classDecl.getMethods()) {
            if (!method.isConstructorDeclaration()) {
                MethodModel methodModel = parseMethod(method);
                classModel.addMethod(methodModel);
            }
        }

        return classModel;
    }

    private FieldModel parseField(FieldDeclaration fieldDecl, VariableDeclarator variable) {
        Visibility visibility = parseVisibility(fieldDecl.getModifiers());
        boolean isStatic = fieldDecl.hasModifier(Modifier.Keyword.STATIC);
        boolean isFinal = fieldDecl.hasModifier(Modifier.Keyword.FINAL);
        String returnType = fieldDecl.getElementType().asString();
        String name = variable.getNameAsString();
        String declaredValue = variable.getInitializer()
            .map(expr -> expr.toString())
            .orElse(null);

        return new FieldModel(visibility, isStatic, isFinal, returnType, name, declaredValue);
    }

    private MethodModel parseMethod(MethodDeclaration methodDecl) {
        Visibility visibility = parseVisibility(methodDecl.getModifiers());
        boolean isStatic = methodDecl.hasModifier(Modifier.Keyword.STATIC);
        boolean isFinal = methodDecl.hasModifier(Modifier.Keyword.FINAL);
        String returnType = methodDecl.getType().asString();
        String name = methodDecl.getNameAsString();

        MethodModel methodModel = new MethodModel(visibility, isStatic, isFinal, returnType, name);

        // Parse parameters
        methodDecl.getParameters().forEach(param -> {
            ParameterModel paramModel = new ParameterModel(
                param.getType().asString(),
                param.getNameAsString()
            );
            methodModel.getParameters().add(paramModel);
        });

        return methodModel;
    }

    private Visibility parseVisibility(com.github.javaparser.ast.NodeList<Modifier> modifiers) {
        if (modifiers.contains(Modifier.publicModifier())) return Visibility.PUBLIC;
        if (modifiers.contains(Modifier.privateModifier())) return Visibility.PRIVATE;
        if (modifiers.contains(Modifier.protectedModifier())) return Visibility.PROTECTED;
        return Visibility.PACAKAGE_PRIVATE;
    }

    private void analyzeRelationships() {
        List<ClassModel> classes = umlModel.getClasses();
        
        for (ClassModel fromClass : classes) {
            for (ClassModel toClass : classes) {
                if (fromClass != toClass) {
                    analyzeRelationshipBetween(fromClass, toClass);
                }
            }
        }
    }

    private void analyzeRelationshipBetween(ClassModel fromClass, ClassModel toClass) {
        // Check for composition/aggregation through fields
        for (FieldModel field : fromClass.getFields()) {
            String fieldType = field.getReturnType();
            if (fieldType.contains(toClass.getClassName())) {
                DependencyType depType = determineFieldRelationType(field, fieldType);
                DependencyModel dependency = new DependencyModel(fromClass, toClass, depType);
                umlModel.addRelationshipToDiagram(dependency);
            }
        }

        // Check for dependencies through method parameters
        for (MethodModel method : fromClass.getMethods()) {
            for (ParameterModel param : method.getParameters()) {
                if (param.getDataType().contains(toClass.getClassName())) {
                    DependencyModel dependency = new DependencyModel(
                        fromClass, toClass, DependencyType.DEPENDENCY
                    );
                    umlModel.addRelationshipToDiagram(dependency);
                }
            }
        }
    }

    private DependencyType determineFieldRelationType(FieldModel field, String fieldType) {
        // Simple heuristics - can be enhanced
        if (fieldType.startsWith("List<") || fieldType.startsWith("ArrayList<") || 
            fieldType.startsWith("Set<") || fieldType.contains("[]")) {
            return DependencyType.AGGREGATION;
        }
        return DependencyType.ASSOCIATION;
    }

    public void shutdown() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
        }
    }
}